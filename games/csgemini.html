<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>CS Clone - Stage 22: Economy & Shop</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Verdana', sans-serif; user-select: none; }
        canvas { display: block; }

        /* UI Base */
        #blocker {
            position: absolute; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.75);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: #fff; z-index: 10;
        }
        
        #shop-ui {
            display: none; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid #ffcc00; padding: 20px;
            width: 600px; color: white; z-index: 20;
            box-shadow: 0 0 20px rgba(255, 204, 0, 0.2);
            font-family: 'Courier New', monospace;
        }
        .shop-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px; }
        .shop-btn {
            background: #333; border: 1px solid #555; color: white;
            padding: 15px; cursor: pointer; text-align: left;
            transition: 0.2s; display: flex; justify-content: space-between;
        }
        .shop-btn:hover { background: #444; border-color: #fff; }
        .shop-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .price { color: #00ff00; font-weight: bold; }
        .owned { color: #ffcc00; font-size: 12px; }

        #scope {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 25%, #000 25.5%);
            pointer-events: none; z-index: 6;
        }
        #scope::before { content: ''; position: absolute; top: 50%; left: 0; width: 100%; height: 2px; background: #000; margin-top: -1px; }
        #scope::after { content: ''; position: absolute; left: 50%; top: 0; width: 2px; height: 100%; background: #000; margin-left: -1px; }

        #crosshair-container {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; z-index: 5;
            display: flex; align-items: center; justify-content: center;
        }

        #crosshair {
            position: relative;
            transition: gap 0.08s ease-out;
            display: flex; align-items: center; justify-content: center;
        }
        .ch-line { position: absolute; background-color: #00ff00; opacity: 0.9; box-shadow: 0 0 2px #000; }
        .ch-h { width: 10px; height: 2px; } .ch-v { height: 10px; width: 2px; }
        #ch-top { bottom: 4px; } #ch-btm { top: 4px; }
        #ch-left { right: 4px; } #ch-right { left: 4px; }

        #hitmarker {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 30px; height: 30px;
            pointer-events: none; opacity: 0; z-index: 5;
        }
        .hm-line { position: absolute; background: #fff; box-shadow: 0 0 2px #000; }
        .hm-v { width: 2px; height: 100%; left: 50%; margin-left: -1px; }
        .hm-h { height: 2px; width: 100%; top: 50%; margin-top: -1px; }

        #hud {
            position: absolute; bottom: 20px; left: 20px;
            color: #00ff00; font-size: 24px; font-weight: bold;
            text-shadow: 2px 2px 0 #000; pointer-events: none;
            display: flex; gap: 40px; align-items: flex-end;
        }
        #weapon-name { font-size: 18px; color: #ffcc00; margin-bottom: 2px; }
        #money { color: #85bb65; text-shadow: 1px 1px 0 #000; }
        
        #top-hud {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            color: #fff; font-size: 24px; font-weight: bold; text-shadow: 1px 1px 3px #000;
            background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 5px;
        }

        #killfeed {
            position: absolute; top: 20px; right: 20px;
            text-align: right; pointer-events: none;
            display: flex; flex-direction: column; gap: 5px;
        }
        .kill-msg {
            background-color: rgba(0,0,0,0.6); color: #FFA500;
            padding: 4px 8px; border-radius: 2px; font-size: 13px; font-weight: bold;
            animation: fadeout 5s forwards; border-left: 3px solid #FFA500;
        }
        .wave-msg {
            color: #00ccff; font-size: 32px; font-weight: bold;
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
            text-shadow: 0 0 10px #00ccff; opacity: 0; animation: waveAnim 3s forwards;
            pointer-events: none;
        }
        .loot-msg {
            color: #85bb65; font-size: 24px; font-weight: bold;
            position: absolute; bottom: 150px; left: 50%; transform: translate(-50%, 0);
            text-shadow: 0 0 5px #00ff00; animation: fadeout 1.5s forwards;
            pointer-events: none;
        }

        @keyframes fadeout { 0% { opacity: 1; } 100% { opacity: 0; } }
        @keyframes waveAnim { 0% { opacity: 0; transform: translate(-50%, -40%); } 20% { opacity: 1; transform: translate(-50%, -50%); } 80% { opacity: 1; } 100% { opacity: 0; } }

        #damage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, red 150%);
            opacity: 0; pointer-events: none; transition: opacity 0.2s;
            z-index: 4;
        }

        #game-over-msg { display: none; font-size: 48px; font-weight: bold; text-shadow: 2px 2px 5px #000; margin-bottom: 20px; }
        #restart-btn { display: none; padding: 10px 20px; font-size: 20px; background: #444; color: white; border: 1px solid #fff; cursor: pointer; }
        #restart-btn:hover { background: #666; }
        .lose { color: #ff3333; } 
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="damage-overlay"></div>
    <div id="scope"></div> 
    
    <div id="hitmarker">
        <div class="hm-line hm-v"></div>
        <div class="hm-line hm-h"></div>
    </div>

    <!-- Shop UI -->
    <div id="shop-ui">
        <h2 style="margin:0; border-bottom:1px solid #555; padding-bottom:10px;">BUY MENU (Balance: <span id="shop-money">$800</span>)</h2>
        <div class="shop-grid">
            <button class="shop-btn" onclick="buyItem('rifle')">
                <span>CV-47 Rifle</span>
                <div><span class="price">$2500</span> <span id="own-rifle"></span></div>
            </button>
            <button class="shop-btn" onclick="buyItem('shotgun')">
                <span>Leone YG Shotgun</span>
                <div><span class="price">$1500</span> <span id="own-shotgun"></span></div>
            </button>
            <button class="shop-btn" onclick="buyItem('awp')">
                <span>Magnum Sniper</span>
                <div><span class="price">$4750</span> <span id="own-awp"></span></div>
            </button>
            <button class="shop-btn" onclick="buyItem('armor')">
                <span>Kevlar Vest (+100)</span>
                <span class="price">$650</span>
            </button>
            <button class="shop-btn" onclick="buyItem('health')">
                <span>Medkit (+50 HP)</span>
                <span class="price">$200</span>
            </button>
            <button class="shop-btn" onclick="buyItem('ammo')">
                <span>Max Ammo (All)</span>
                <span class="price">$400</span>
            </button>
        </div>
        <div style="margin-top:20px; text-align:right;">
            <button class="shop-btn" style="width:100%; justify-content:center;" onclick="toggleShop()">CLOSE SHOP (B)</button>
        </div>
    </div>

    <div id="blocker">
        <div id="instructions">
            <h1 style="margin:0">CS JS: STAGE 22</h1>
            <p style="color:#aaa">ECONOMY UPDATE</p>
            <br>
            <p>Press <b>'B'</b> to Buy Weapons.</p>
            <p>Kill enemies to earn money.</p>
            <p style="font-size:14px; margin-top:20px; color:#666">Click to Start</p>
        </div>
        <div id="game-over-msg"></div>
        <button id="restart-btn">PLAY AGAIN</button>
    </div>

    <div id="top-hud">Wave: 1 | Enemies: 0</div>

    <div id="crosshair-container">
        <div id="crosshair">
            <div id="ch-top" class="ch-line ch-v"></div>
            <div id="ch-btm" class="ch-line ch-v"></div>
            <div id="ch-left" class="ch-line ch-h"></div>
            <div id="ch-right" class="ch-line ch-h"></div>
        </div>
    </div>

    <div id="killfeed"></div>
    <div id="hud">
        <div id="health">‚ûï 100</div>
        <div id="armor">üõ°Ô∏è 0</div>
        <div id="money">üí≤ 800</div>
        <div>
            <div id="weapon-name">Pistol</div>
            <div id="ammo">12 / 48</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // GLOBAL EXPORTS FOR HTML ONCLICK
        window.buyItem = buyItem;
        window.toggleShop = toggleShop;

        let camera, scene, renderer, controls;
        let cameraWeapon, sceneWeapon, weaponGroup;
        let muzzleLight;

        // Game State
        let wave = 1;
        let enemiesRemaining = 0;
        let waveInProgress = false;
        let playerMoney = 800;
        let isShopOpen = false;

        let playerHealth = 100; let playerArmor = 0; let isDead = false;
        const PLAYER_HEIGHT = 16; 
        
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const speed = 400; const jumpHeight = 160; 
        let prevTime = performance.now();
        let isMoving = false; let stepTimer = 0;
        
        const mapObjects = []; const wallColliders = []; const decals = []; const shells = [];
        const particles = []; 
        const lootDrops = []; 
        let enemies = [];
        let barrels = []; 
        let raycaster;
        
        const weapons = {
            pistol: {
                name: "KM .45", damage: 20, fireRate: 150, auto: false,
                mag: 12, reserve: 48, maxRes: 100,
                recoil: 0.2, maxRecoil: 0.6, spread: 0.01, shotgun: false,
                mesh: null, ammoCur: 12, ammoRes: 48, hasScope: false, owned: true, price: 0
            },
            rifle: {
                name: "CV-47", damage: 32, fireRate: 100, auto: true,
                mag: 30, reserve: 90, maxRes: 180,
                recoil: 0.1, maxRecoil: 0.5, spread: 0.02, shotgun: false,
                mesh: null, ammoCur: 30, ammoRes: 90, hasScope: false, owned: false, price: 2500
            },
            shotgun: {
                name: "Leone YG", damage: 18, fireRate: 900, auto: false,
                mag: 8, reserve: 32, maxRes: 64,
                recoil: 2.5, maxRecoil: 3.0, spread: 0.08, shotgun: true, pellets: 8,
                mesh: null, ammoCur: 8, ammoRes: 32, hasScope: false, owned: false, price: 1500
            },
            awp: {
                name: "Magnum Sniper", damage: 105, fireRate: 1400, auto: false, 
                mag: 10, reserve: 30, maxRes: 50,
                recoil: 1.0, maxRecoil: 2.0, spread: 0.0, shotgun: false,
                noScopeSpread: 0.3, 
                mesh: null, ammoCur: 10, ammoRes: 30, hasScope: true, owned: false, price: 4750
            }
        };
        let currentWeapon = weapons.pistol;
        let isFiring = false;
        let lastFireTime = 0; 
        let isReloading = false;
        let currentRecoil = 0;
        let dynamicGap = 4; 
        let swayX = 0; let swayY = 0; let swayTime = 0;
        let isScoped = false;

        let audioCtx, shootBufferPistol, shootBufferRifle, shootBufferAWP, shootBufferShotgun, stepBuffer, explodeBuffer, buyBuffer;
        
        const ui = {
            ammo: document.getElementById('ammo'),
            wName: document.getElementById('weapon-name'),
            health: document.getElementById('health'),
            armor: document.getElementById('armor'),
            money: document.getElementById('money'),
            shopMoney: document.getElementById('shop-money'),
            killfeed: document.getElementById('killfeed'),
            damageOverlay: document.getElementById('damage-overlay'),
            gameOverMsg: document.getElementById('game-over-msg'),
            instructions: document.getElementById('instructions'),
            blocker: document.getElementById('blocker'),
            restartBtn: document.getElementById('restart-btn'),
            crosshair: document.getElementById('crosshair'),
            hitmarker: document.getElementById('hitmarker'),
            scope: document.getElementById('scope'),
            topHud: document.getElementById('top-hud'),
            shop: document.getElementById('shop-ui'),
            crosshairParts: [ document.getElementById('ch-top'), document.getElementById('ch-btm'), document.getElementById('ch-left'), document.getElementById('ch-right') ]
        };

        init();
        animate();

        function createTexture(type) {
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            if (type === 'concrete') {
                ctx.fillStyle = '#909090'; ctx.fillRect(0,0,512,512);
                for(let i=0; i<8000; i++) { ctx.fillStyle = Math.random() > 0.5 ? '#808080' : '#A0A0A0'; ctx.fillRect(Math.random()*512, Math.random()*512, 2, 2); }
            } else if (type === 'crate') {
                ctx.fillStyle = '#8B4513'; ctx.fillRect(0,0,512,512); ctx.lineWidth = 15; ctx.strokeStyle = '#5c2e0a'; ctx.strokeRect(0,0,512,512);
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(512,512); ctx.moveTo(512,0); ctx.lineTo(0,512); ctx.stroke();
            } else if (type === 'floor') {
                ctx.fillStyle = '#e0cda8'; ctx.fillRect(0,0,512,512); ctx.fillStyle = '#d1ba8e';
                for(let i=0; i<512; i+=128) ctx.fillRect(i, 0, 4, 512); for(let i=0; i<512; i+=128) ctx.fillRect(0, i, 512, 4);
            } else if (type === 'ammo') {
                ctx.fillStyle = '#225522'; ctx.fillRect(0,0,512,512); 
                ctx.fillStyle = '#00ff00'; ctx.font = "bold 200px Arial"; ctx.textAlign = "center"; ctx.fillText("AMMO", 256, 300);
                ctx.lineWidth = 20; ctx.strokeStyle = '#00ff00'; ctx.strokeRect(20,20,472,472);
            } else if (type === 'barrel') {
                ctx.fillStyle = '#cc0000'; ctx.fillRect(0,0,512,512);
                ctx.fillStyle = '#ffcc00'; ctx.beginPath(); ctx.moveTo(256, 150); ctx.lineTo(350, 350); ctx.lineTo(162, 350); ctx.fill(); 
                ctx.lineWidth=10; ctx.strokeRect(0,0,512,50); ctx.strokeRect(0,462,512,50);
            }
            const tex = new THREE.CanvasTexture(canvas); tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping; return tex;
        }

        function init() {
            scene = new THREE.Scene(); 
            scene.background = new THREE.Color(0x87CEEB); 
            scene.fog = new THREE.Fog(0x87CEEB, 20, 300); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000); 
            camera.position.y = PLAYER_HEIGHT;
            
            sceneWeapon = new THREE.Scene(); cameraWeapon = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            [scene, sceneWeapon].forEach(s => { s.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.4)); });
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(100, 200, 100); dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5; dirLight.shadow.camera.far = 500;
            dirLight.shadow.camera.left = -200; dirLight.shadow.camera.right = 200;
            dirLight.shadow.camera.top = 200; dirLight.shadow.camera.bottom = -200;
            scene.add(dirLight);

            createSky();
            muzzleLight = new THREE.PointLight(0xffaa00, 0, 20); muzzleLight.position.set(0, 0, -2); sceneWeapon.add(muzzleLight);

            controls = new PointerLockControls(camera, document.body);
            ui.instructions.addEventListener('click', () => { if(!isDead) controls.lock(); initAudio(); startWave(); });
            ui.restartBtn.addEventListener('click', () => location.reload());
            controls.addEventListener('lock', () => { 
                if(isShopOpen) return; // Don't hide if just re-locking after shop close
                ui.instructions.style.display = 'none'; ui.blocker.style.display = 'none'; ui.shop.style.display = 'none';
            });
            controls.addEventListener('unlock', () => { 
                if(isShopOpen) {
                    // Shop is open, keep cursor visible but don't show "Game Over" blocker
                } else if(!isDead) { 
                    ui.blocker.style.display = 'flex'; ui.instructions.style.display = ''; 
                } 
            });
            scene.add(controls.getObject());

            const keyHandler = (e, pressed) => {
                switch (e.code) {
                    case 'KeyW': moveForward = pressed; break; case 'KeyA': moveLeft = pressed; break;
                    case 'KeyS': moveBackward = pressed; break; case 'KeyD': moveRight = pressed; break;
                    case 'Space': if (pressed && canJump) { velocity.y += jumpHeight; canJump = false; } break;
                    case 'KeyR': if(pressed) reload(); break;
                    case 'Digit1': if(pressed) switchWeapon('rifle'); break;
                    case 'Digit2': if(pressed) switchWeapon('pistol'); break;
                    case 'Digit3': if(pressed) switchWeapon('awp'); break;
                    case 'Digit4': if(pressed) switchWeapon('shotgun'); break;
                    case 'KeyB': if(pressed && !isDead) toggleShop(); break;
                }
            };
            document.addEventListener('keydown', (e) => keyHandler(e, true));
            document.addEventListener('keyup', (e) => keyHandler(e, false));
            
            document.addEventListener('mousedown', (e) => { 
                if(isShopOpen) return;
                if(controls.isLocked) {
                    if (e.button === 0) { isFiring = true; if (!currentWeapon.auto) fire(); } 
                    else if (e.button === 2) { if (currentWeapon.hasScope) toggleScope(); }
                }
            });
            document.addEventListener('mouseup', () => { isFiring = false; });
            document.addEventListener('contextmenu', event => event.preventDefault());

            const texFloor = createTexture('floor'); texFloor.repeat.set(20, 20);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.MeshLambertMaterial({ map: texFloor }));
            floor.rotation.x = -Math.PI / 2; floor.receiveShadow = true; 
            scene.add(floor); mapObjects.push(floor); 
            
            const boxGeo = new THREE.BoxGeometry(20, 20, 20); const boxMat = new THREE.MeshLambertMaterial({ map: createTexture('crate') });
            for (let i = 0; i < 60; i++) {
                let x = Math.floor(Math.random() * 25 - 12) * 20; let z = Math.floor(Math.random() * 25 - 12) * 20;
                if (Math.abs(x) < 40 && Math.abs(z) < 40) continue;
                const box = new THREE.Mesh(boxGeo, boxMat); box.position.set(x, 10, z);
                box.castShadow = true; box.receiveShadow = true; 
                scene.add(box); mapObjects.push(box); wallColliders.push(new THREE.Box3().setFromObject(box));
            }

            for(let i=0; i<8; i++) spawnBarrel();
            
            raycaster = new THREE.Raycaster(); initWeapons();
            
            renderer = new THREE.WebGLRenderer({ antialias: true }); 
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(window.innerWidth, window.innerHeight); renderer.autoClear = false;
            document.body.appendChild(renderer.domElement); window.addEventListener('resize', onWindowResize);
            
            updateShopUI();
            updateHUD();
        }

        // ECONOMY & SHOP FUNCTIONS
        function toggleShop() {
            isShopOpen = !isShopOpen;
            if (isShopOpen) {
                controls.unlock();
                ui.shop.style.display = 'block';
                ui.blocker.style.display = 'none';
                updateShopUI();
            } else {
                ui.shop.style.display = 'none';
                controls.lock();
            }
        }

        function buyItem(type) {
            let cost = 0;
            let success = false;

            if (type === 'armor') {
                cost = 650;
                if (playerMoney >= cost && playerArmor < 100) {
                    playerMoney -= cost; playerArmor = 100; success = true;
                }
            } else if (type === 'health') {
                cost = 200;
                if (playerMoney >= cost && playerHealth < 100) {
                    playerMoney -= cost; playerHealth = Math.min(playerHealth + 50, 100); success = true;
                }
            } else if (type === 'ammo') {
                cost = 400;
                if (playerMoney >= cost) {
                    playerMoney -= cost;
                    // Fill all owned weapons
                    if(weapons.pistol.owned) weapons.pistol.ammoRes = weapons.pistol.maxRes;
                    if(weapons.rifle.owned) weapons.rifle.ammoRes = weapons.rifle.maxRes;
                    if(weapons.shotgun.owned) weapons.shotgun.ammoRes = weapons.shotgun.maxRes;
                    if(weapons.awp.owned) weapons.awp.ammoRes = weapons.awp.maxRes;
                    success = true;
                }
            } else if (weapons[type]) {
                const w = weapons[type];
                cost = w.price;
                if (playerMoney >= cost && !w.owned) {
                    playerMoney -= cost; w.owned = true; w.ammoCur = w.mag; w.ammoRes = w.maxRes; 
                    switchWeapon(type); // Auto switch
                    success = true;
                } else if (playerMoney >= cost/2 && w.owned && w.ammoRes < w.maxRes) {
                    // Rebuy just ammo? Let's just say "Already Owned" for now to keep simple
                }
            }

            if (success) {
                playSound(buyBuffer, 1.0, 0.5);
                updateHUD();
                updateShopUI();
            }
        }

        function updateShopUI() {
            ui.shopMoney.innerText = `$${playerMoney}`;
            document.getElementById('own-rifle').innerText = weapons.rifle.owned ? "OWNED" : "";
            document.getElementById('own-shotgun').innerText = weapons.shotgun.owned ? "OWNED" : "";
            document.getElementById('own-awp').innerText = weapons.awp.owned ? "OWNED" : "";
        }

        function addMoney(amount) {
            playerMoney += amount;
            const msg = document.createElement('div');
            msg.className = 'loot-msg'; msg.style.color = '#85bb65'; msg.style.bottom = '200px';
            msg.innerText = `+$${amount}`;
            document.body.appendChild(msg); setTimeout(() => msg.remove(), 1500);
            updateHUD();
        }

        function createSky() {
            const sunGeo = new THREE.CircleGeometry(20, 32); const sunMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
            const sun = new THREE.Mesh(sunGeo, sunMat); sun.position.set(200, 400, 200); sun.lookAt(0,0,0); scene.add(sun);
            const cloudGeo = new THREE.BoxGeometry(60, 20, 40); const cloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 });
            for(let i=0; i<20; i++) {
                const cloud = new THREE.Mesh(cloudGeo, cloudMat); cloud.position.set((Math.random()-0.5)*800, 150 + Math.random()*50, (Math.random()-0.5)*800); scene.add(cloud);
            }
        }

        function spawnBarrel() {
            const pos = getSafeSpawnPosition();
            const geo = new THREE.CylinderGeometry(3, 3, 10, 16); const mat = new THREE.MeshLambertMaterial({ map: createTexture('barrel') });
            const barrel = new THREE.Mesh(geo, mat); barrel.position.set(pos.x, 5, pos.z); barrel.castShadow = true; barrel.receiveShadow = true;
            barrel.userData = { type: 'barrel', hp: 50 }; scene.add(barrel); mapObjects.push(barrel); barrels.push(barrel); wallColliders.push(new THREE.Box3().setFromObject(barrel));
        }

        function explodeBarrel(barrel) {
            scene.remove(barrel); const idx = mapObjects.indexOf(barrel); if(idx > -1) mapObjects.splice(idx, 1);
            const bIdx = barrels.indexOf(barrel); if(bIdx > -1) barrels.splice(bIdx, 1);
            playSound(explodeBuffer, 1.0, 1.0);
            for(let i=0; i<30; i++) { createParticle(barrel.position, 0xff5500, 20, 2); createParticle(barrel.position, 0x555555, 15, 3); }
            const range = 40; const damage = 200;
            enemies.forEach(g => { if(!g.userData.alive) return; if(g.position.distanceTo(barrel.position) < range) { g.userData.hp -= damage; if(g.userData.hp <= 0) killEnemy(g, false); createParticle(g.position, 0xaa0000, 10, 1); } });
            const pPos = controls.getObject().position; const dist = pPos.distanceTo(barrel.position); if(dist < range) { takeDamage(Math.floor(damage * (1 - dist/range))); }
        }

        function createParticle(pos, color, speedVal, scaleVal) {
            const geo = new THREE.BoxGeometry(scaleVal, scaleVal, scaleVal); const mat = new THREE.MeshBasicMaterial({ color: color });
            const p = new THREE.Mesh(geo, mat); p.position.copy(pos);
            p.userData = { vel: new THREE.Vector3((Math.random()-0.5), (Math.random()-0.5) + 0.5, (Math.random()-0.5)).normalize().multiplyScalar(Math.random() * speedVal), life: 1.0, decay: 0.02 + Math.random() * 0.03 };
            scene.add(p); particles.push(p);
        }

        function getSafeSpawnPosition() {
            const playerPos = controls.getObject().position; const enemyBox = new THREE.Box3(); const size = 3; 
            for(let i=0; i<50; i++) {
                const x = (Math.random() - 0.5) * 400; const z = (Math.random() - 0.5) * 400;
                const dx = x - playerPos.x; const dz = z - playerPos.z; if ((dx*dx + dz*dz) < 900) continue; 
                enemyBox.min.set(x - size, 0, z - size); enemyBox.max.set(x + size, 20, z + size);
                let intersect = false; for(let wall of wallColliders) { if(wall.intersectsBox(enemyBox)) { intersect = true; break; } }
                if(!intersect) return { x: x, z: z };
            }
            return { x: 40, z: 40 }; 
        }

        function startWave() {
            if (waveInProgress) return;
            waveInProgress = true;
            const count = 3 + wave; 
            enemiesRemaining = count;
            
            const msg = document.createElement('div'); msg.className = 'wave-msg'; msg.innerText = `WAVE ${wave}`;
            if (wave % 5 === 0) { msg.innerText = "BOSS WAVE"; msg.style.color = "red"; }
            document.body.appendChild(msg); setTimeout(() => msg.remove(), 3000);

            if (wave % 5 === 0) {
                 const pos = getSafeSpawnPosition(); spawnEnemy(pos.x, pos.z, true); 
                 for(let i=0; i<Math.max(1, count/2); i++) { const p = getSafeSpawnPosition(); spawnEnemy(p.x, p.z); }
                 enemiesRemaining = 1 + Math.max(1, Math.floor(count/2));
            } else {
                for(let i=0; i<count; i++) { const pos = getSafeSpawnPosition(); spawnEnemy(pos.x, pos.z); }
            }
            if(barrels.length < 5) spawnBarrel();
            updateTopHud();
        }

        function updateTopHud() { ui.topHud.innerText = `Wave: ${wave} | Enemies: ${enemiesRemaining}`; }

        function spawnEnemy(x, z, isBoss = false) {
            const group = new THREE.Group(); group.position.set(x, 0, z);
            const hp = isBoss ? 500 : (100 + wave * 10);
            const scale = isBoss ? 2.0 : 1.0;
            group.userData = { type: 'enemy', hp: hp, maxHp: hp, lastShot: performance.now(), alive: true, isBoss: isBoss };
            group.scale.set(scale, scale, scale);
            const legGeo = new THREE.BoxGeometry(2.5, 7, 2.5); const pantsMat = new THREE.MeshLambertMaterial({ color: isBoss ? 0x000000 : 0x1a2b4c });
            const leftLeg = new THREE.Mesh(legGeo, pantsMat); leftLeg.position.set(-1.5, 3.5, 0); leftLeg.castShadow = true; group.add(leftLeg);
            const rightLeg = new THREE.Mesh(legGeo, pantsMat); rightLeg.position.set(1.5, 3.5, 0); rightLeg.castShadow = true; group.add(rightLeg);
            const torsoGeo = new THREE.BoxGeometry(6, 8, 3.5); const torsoMat = new THREE.MeshLambertMaterial({ color: isBoss ? 0x330000 : 0x7a1a1a });
            const torso = new THREE.Mesh(torsoGeo, torsoMat); torso.position.y = 11; torso.userData = { parentGroup: group, isHead: false }; torso.castShadow = true; group.add(torso);
            const headGeo = new THREE.BoxGeometry(3.5, 3.5, 3.5); const skinMat = new THREE.MeshLambertMaterial({ color: 0xffd1a4 });
            const head = new THREE.Mesh(headGeo, skinMat); head.position.y = 16.75; head.userData = { parentGroup: group, isHead: true }; head.castShadow = true; group.add(head);
            const armGeo = new THREE.BoxGeometry(2, 6, 2); const arm = new THREE.Mesh(armGeo, torsoMat);
            arm.position.set(4, 11, 2); arm.rotation.x = -Math.PI / 2; arm.castShadow = true; group.add(arm);
            const hbGeo = new THREE.PlaneGeometry(10, 1); const hbMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
            const hpBar = new THREE.Mesh(hbGeo, hbMat); hpBar.position.y = 22; hpBar.userData = { isHpBar: true }; group.add(hpBar); group.userData.hpBar = hpBar;
            scene.add(group); enemies.push(group); mapObjects.push(torso); mapObjects.push(head);
        }

        function spawnLoot(x, z) {
            const geo = new THREE.BoxGeometry(5, 5, 5); const mat = new THREE.MeshBasicMaterial({ map: createTexture('ammo') });
            const box = new THREE.Mesh(geo, mat); box.position.set(x, 2.5, z);
            const wire = new THREE.LineSegments(new THREE.WireframeGeometry(geo), new THREE.LineBasicMaterial({color: 0x00ff00})); box.add(wire);
            scene.add(box); lootDrops.push(box);
        }

        function checkLootPickup() {
            const pPos = controls.getObject().position;
            for(let i=lootDrops.length-1; i>=0; i--) {
                const box = lootDrops[i];
                if(pPos.distanceTo(box.position) < 8) {
                    scene.remove(box); lootDrops.splice(i, 1);
                    if(weapons.pistol.owned) weapons.pistol.ammoRes = Math.min(weapons.pistol.ammoRes + 24, weapons.pistol.maxRes);
                    if(weapons.rifle.owned) weapons.rifle.ammoRes = Math.min(weapons.rifle.ammoRes + 60, weapons.rifle.maxRes);
                    if(weapons.shotgun.owned) weapons.shotgun.ammoRes = Math.min(weapons.shotgun.ammoRes + 16, weapons.shotgun.maxRes);
                    if(weapons.awp.owned) weapons.awp.ammoRes = Math.min(weapons.awp.ammoRes + 10, weapons.awp.maxRes);
                    updateHUD(); playSound(stepBuffer, 2.0, 1.0);
                    const msg = document.createElement('div'); msg.className = 'loot-msg'; msg.innerText = `+ AMMO`;
                    document.body.appendChild(msg); setTimeout(() => msg.remove(), 2000);
                }
            }
        }

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const createNoise = (dur, type) => {
                const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * dur, audioCtx.sampleRate);
                const d = buf.getChannelData(0); for (let i = 0; i < buf.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/buf.length, type);
                return buf;
            };
            shootBufferPistol = createNoise(0.15, 2); shootBufferRifle = createNoise(0.1, 1);
            const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.4, audioCtx.sampleRate);
            const d = buf.getChannelData(0); for (let i = 0; i < buf.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/buf.length, 0.5); 
            shootBufferAWP = buf; stepBuffer = createNoise(0.05, 5);
            const sBuf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.3, audioCtx.sampleRate);
            const sd = sBuf.getChannelData(0); for(let i=0; i<sBuf.length; i++) sd[i] = (Math.random()*2-1) * Math.pow(1 - i/sBuf.length, 0.2);
            shootBufferShotgun = sBuf;
            const eBuf = audioCtx.createBuffer(1, audioCtx.sampleRate * 1.0, audioCtx.sampleRate);
            const ed = eBuf.getChannelData(0); for(let i=0; i<eBuf.length; i++) ed[i] = (Math.random()*2-1) * Math.pow(1 - i/eBuf.length, 0.1);
            explodeBuffer = eBuf;
            // Buy Sound (Cash register ish)
            const bBuf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.2, audioCtx.sampleRate);
            const bd = bBuf.getChannelData(0); for(let i=0; i<bBuf.length; i++) bd[i] = Math.sin(i * 0.1) * Math.exp(-i * 0.005);
            buyBuffer = bBuf;
        }

        function playSound(buffer, pitch = 1, vol = 1, filterFreq = 0) {
            if (!audioCtx) return;
            const src = audioCtx.createBufferSource(); src.buffer = buffer; src.playbackRate.value = pitch;
            const gain = audioCtx.createGain(); gain.gain.value = vol;
            src.connect(gain);
            if (filterFreq > 0) { const f = audioCtx.createBiquadFilter(); f.type = "lowpass"; f.frequency.value = filterFreq; gain.connect(f); f.connect(audioCtx.destination);
            } else { gain.connect(audioCtx.destination); }
            src.start();
        }

        function initWeapons() {
            weaponGroup = new THREE.Group(); sceneWeapon.add(weaponGroup);
            const pistolG = new THREE.Group(); pistolG.add(new THREE.Mesh(new THREE.BoxGeometry(2, 2, 8), new THREE.MeshLambertMaterial({ color: 0x333333 }))); weapons.pistol.mesh = pistolG;
            const rifleG = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(2.5, 3, 14), new THREE.MeshLambertMaterial({ color: 0x444444 }));
            const mag = new THREE.Mesh(new THREE.BoxGeometry(2, 6, 4), new THREE.MeshLambertMaterial({ color: 0x222222 })); mag.position.set(0, -3, 2); mag.rotation.x = 0.2;
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 8), new THREE.MeshLambertMaterial({ color: 0x111111 })); barrel.rotation.x = -Math.PI/2; barrel.position.set(0, 0.5, -9);
            const stock = new THREE.Mesh(new THREE.BoxGeometry(2, 4, 6), new THREE.MeshLambertMaterial({ color: 0x5c2e0a })); stock.position.set(0, -0.5, 8);
            rifleG.add(body, mag, barrel, stock); weapons.rifle.mesh = rifleG;
            const awpG = new THREE.Group();
            const aBody = new THREE.Mesh(new THREE.BoxGeometry(3, 4, 16), new THREE.MeshLambertMaterial({ color: 0x2E8B57 })); 
            const aBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 12), new THREE.MeshLambertMaterial({ color: 0x111111 })); aBarrel.rotation.x = -Math.PI/2; aBarrel.position.set(0, 0.5, -14);
            const aScope = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 6), new THREE.MeshLambertMaterial({ color: 0x111111 })); aScope.position.set(0, 3.5, 0);
            awpG.add(aBody, aBarrel, aScope); weapons.awp.mesh = awpG;
            const shotG = new THREE.Group();
            const sBody = new THREE.Mesh(new THREE.BoxGeometry(3, 4, 14), new THREE.MeshLambertMaterial({ color: 0x552200 }));
            const sBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 10), new THREE.MeshLambertMaterial({ color: 0x222222 })); sBarrel.rotation.x = -Math.PI/2; sBarrel.position.set(0, 0.5, -12);
            const pump = new THREE.Mesh(new THREE.BoxGeometry(3.2, 2, 6), new THREE.MeshLambertMaterial({ color: 0x111111 })); pump.position.set(0, -1, -8);
            shotG.add(sBody, sBarrel, pump); weapons.shotgun.mesh = shotG;

            [weapons.pistol.mesh, weapons.rifle.mesh, weapons.awp.mesh, weapons.shotgun.mesh].forEach(m => { m.position.set(3, -2.5, -6); weaponGroup.add(m); });
            switchWeapon('pistol'); // START WITH PISTOL
        }

        function switchWeapon(type) {
            if (isReloading) return; if (isScoped) toggleScope();
            if (!weapons[type].owned) return; // Cant switch if not owned

            currentWeapon = weapons[type];
            weapons.rifle.mesh.visible = (type === 'rifle'); 
            weapons.pistol.mesh.visible = (type === 'pistol'); 
            weapons.awp.mesh.visible = (type === 'awp');
            weapons.shotgun.mesh.visible = (type === 'shotgun');
            ui.crosshair.parentElement.style.display = (type === 'awp') ? 'none' : 'flex';
            updateHUD(); weaponGroup.position.y -= 2;
        }

        function toggleScope() {
            if (!currentWeapon.hasScope) return; isScoped = !isScoped;
            if (isScoped) { camera.fov = 20; ui.scope.style.display = 'block'; weaponGroup.visible = false; } else { camera.fov = 75; ui.scope.style.display = 'none'; weaponGroup.visible = true; }
            camera.updateProjectionMatrix();
        }

        function createShell() {
            const geo = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 6); const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const shell = new THREE.Mesh(geo, mat);
            const pPos = controls.getObject().position.clone(); const offset = new THREE.Vector3(1, -1, 1).applyQuaternion(camera.quaternion);
            shell.position.copy(pPos).add(offset); shell.userData = { vel: new THREE.Vector3(Math.random()*0.5, Math.random()*2, Math.random()*0.5), life: 100 };
            scene.add(shell); shells.push(shell);
        }

        function showHitmarker() {
            ui.hitmarker.style.opacity = 1; ui.hitmarker.style.transform = "translate(-50%, -50%) rotate(45deg) scale(1.2)";
            setTimeout(() => { ui.hitmarker.style.transform = "translate(-50%, -50%) rotate(45deg) scale(1.0)"; }, 50);
        }

        function reload() {
            if (isReloading || currentWeapon.ammoCur === currentWeapon.mag || currentWeapon.ammoRes === 0) return;
            if (isScoped) toggleScope(); isReloading = true; isFiring = false;
            setTimeout(() => {
                const need = currentWeapon.mag - currentWeapon.ammoCur; const take = Math.min(need, currentWeapon.ammoRes);
                currentWeapon.ammoCur += take; currentWeapon.ammoRes -= take; updateHUD(); isReloading = false;
            }, 1500); 
        }

        function fire() {
            if (isReloading || currentWeapon.ammoCur <= 0 || isDead) { if(currentWeapon.ammoCur <= 0) reload(); return; }
            const time = performance.now(); if (time - lastFireTime < currentWeapon.fireRate) return; lastFireTime = time;

            currentWeapon.ammoCur--; updateHUD(); muzzleLight.intensity = 2.0;
            let buf = shootBufferPistol; 
            if (currentWeapon === weapons.rifle) buf = shootBufferRifle; 
            if (currentWeapon === weapons.awp) buf = shootBufferAWP;
            if (currentWeapon === weapons.shotgun) buf = shootBufferShotgun;
            playSound(buf, 1.0, 0.8, 1200 + Math.random()*200);
            
            if (currentRecoil < currentWeapon.maxRecoil) currentRecoil += currentWeapon.recoil; else currentRecoil = currentWeapon.maxRecoil;
            if (currentWeapon !== weapons.awp) dynamicGap += (currentWeapon.shotgun ? 12 : 4); 
            createShell();
            
            let pelletCount = currentWeapon.pellets || 1;
            
            for (let i = 0; i < pelletCount; i++) {
                let spreadFactor = currentWeapon.spread * (1 + currentRecoil * 1.5);
                if (currentWeapon === weapons.awp) { if (isScoped) spreadFactor = 0; else spreadFactor = currentWeapon.noScopeSpread; }

                const spreadX = (Math.random() - 0.5) * spreadFactor; const spreadY = (Math.random() - 0.5) * spreadFactor;
                const recoilYOffset = currentWeapon.auto ? (currentRecoil * 0.03) : (currentRecoil * 0.05); 
                raycaster.setFromCamera(new THREE.Vector2(spreadX, spreadY + recoilYOffset), camera);
                const intersects = raycaster.intersectObjects(mapObjects);

                if (intersects.length > 0) {
                    const hit = intersects[0]; const obj = hit.object;
                    
                    if (obj.userData && obj.userData.type === 'barrel') {
                        if(i===0) showHitmarker(); 
                        obj.userData.hp -= currentWeapon.damage;
                        createParticle(hit.point, 0xffaa00, 5, 1);
                        if(obj.userData.hp <= 0) explodeBarrel(obj);
                        continue;
                    }

                    if (obj.userData && obj.userData.parentGroup) {
                        const enemyGroup = obj.userData.parentGroup;
                        if (enemyGroup.userData.alive) {
                            if(i===0) showHitmarker();
                            let damage = currentWeapon.damage; let isHeadshot = false;
                            if (obj.userData.isHead) { damage *= 4; isHeadshot = true; }
                            damage = Math.floor(damage * (0.8 + Math.random()*0.4));
                            enemyGroup.userData.hp -= damage;
                            createParticle(hit.point, 0xaa0000, 5, 1);
                            
                            if (enemyGroup.userData.hp <= 0) killEnemy(enemyGroup, isHeadshot);
                            else { 
                                obj.material.emissive.setHex(0xff0000); setTimeout(() => { if(obj.material) obj.material.emissive.setHex(0x000000) }, 100); 
                            }
                        }
                    } else { 
                        const hole = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), new THREE.MeshBasicMaterial({ color: 0x000000, polygonOffset: true, polygonOffsetFactor: -1 }));
                        hole.position.copy(hit.point); hole.lookAt(hit.point.clone().add(hit.face.normal)); hole.position.add(hit.face.normal.multiplyScalar(0.01));
                        scene.add(hole); decals.push({ mesh: hole, time: performance.now() });
                        if (decals.length > 50) { scene.remove(decals[0].mesh); decals.shift(); }
                        createParticle(hit.point, 0xaaaaaa, 3, 0.5);
                    }
                }
            }
        }

        function killEnemy(group, isHeadshot) {
            if (!group.userData.alive) return;
            group.userData.alive = false; enemiesRemaining--; updateTopHud();
            if(Math.random() > 0.5) spawnLoot(group.position.x, group.position.z);
            
            // MONEY REWARD
            let money = 300; 
            if (isHeadshot) money += 150;
            if (group.userData.isBoss) money += 1000;
            addMoney(money);

            const duration = 500; const startTime = performance.now();
            group.children.forEach(c => { const idx = mapObjects.indexOf(c); if(idx > -1) mapObjects.splice(idx, 1); });
            const fallAnim = () => {
                const elapsed = performance.now() - startTime; const progress = Math.min(elapsed / duration, 1);
                group.rotation.x = -Math.PI/2 * progress; if (progress < 1) requestAnimationFrame(fallAnim);
            }; fallAnim();

            const msg = document.createElement('div'); msg.className = 'kill-msg';
            msg.innerHTML = isHeadshot ? `Player üî´ <span style='color:red'>HEADSHOT</span>` : `Player üî´`;
            ui.killfeed.appendChild(msg); setTimeout(() => msg.remove(), 5000);
            
            const aliveCount = enemies.filter(e => e.userData.alive).length;
            if (aliveCount === 0) { 
                waveInProgress = false; wave++; 
                addMoney(500); // Wave clear bonus
                setTimeout(() => { startWave(); }, 3000); 
            }
        }

        function takeDamage(amount) {
            if(isDead) return;
            let dmg = amount; if (playerArmor > 0) { playerArmor -= Math.floor(amount * 0.5); if(playerArmor < 0) playerArmor = 0; dmg = Math.floor(amount * 0.5); ui.armor.innerText = `üõ°Ô∏è ${playerArmor}`; }
            playerHealth -= dmg; ui.health.innerText = `‚ûï ${playerHealth}`; ui.damageOverlay.style.opacity = 0.8; setTimeout(() => ui.damageOverlay.style.opacity = 0, 300);
            if (playerHealth <= 0) {
                isDead = true; controls.unlock(); ui.instructions.style.display = 'none'; ui.blocker.style.display = 'flex';
                ui.gameOverMsg.style.display = 'block'; ui.gameOverMsg.innerText = "YOU DIED";
                ui.gameOverMsg.className = "lose"; ui.restartBtn.style.display = 'block';
            }
        }

        function updateHUD() { 
            ui.ammo.innerText = isReloading ? "Reloading..." : `${currentWeapon.ammoCur} / ${currentWeapon.ammoRes}`; 
            ui.wName.innerText = currentWeapon.name; 
            ui.money.innerText = `üí≤ ${playerMoney}`;
            ui.armor.innerText = `üõ°Ô∏è ${playerArmor}`;
            ui.health.innerText = `‚ûï ${playerHealth}`;
        }
        function onWindowResize() { 
            const aspect = window.innerWidth / window.innerHeight; camera.aspect = aspect; camera.updateProjectionMatrix(); 
            cameraWeapon.aspect = aspect; cameraWeapon.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); 
        }
        function checkCollision(pos) {
            const box = new THREE.Box3(); box.min.set(pos.x - 4, pos.y - 10, pos.z - 4); box.max.set(pos.x + 4, pos.y + 2, pos.z + 4);
            for (const w of wallColliders) if (w.intersectsBox(box)) return true;
            return false;
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now(); const delta = (time - prevTime) / 1000; prevTime = time;

            if (ui.hitmarker.style.opacity > 0) ui.hitmarker.style.opacity -= delta * 3;
            if (muzzleLight.intensity > 0) muzzleLight.intensity -= delta * 15; if (muzzleLight.intensity < 0) muzzleLight.intensity = 0;

            if (isFiring && !isReloading && !isDead) { if (currentWeapon.auto) { if (time - lastFireTime >= currentWeapon.fireRate) fire(); } } 
            else if (!isFiring) { if (currentRecoil > 0) currentRecoil -= delta * 1.5; else currentRecoil = 0; }

            if (controls.isLocked === true && !isDead) {
                velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta; velocity.y -= 9.8 * 100.0 * delta; 
                direction.z = Number(moveForward) - Number(moveBackward); direction.x = Number(moveRight) - Number(moveLeft); direction.normalize();
                if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;
                isMoving = (Math.abs(velocity.x) > 1 || Math.abs(velocity.z) > 1);
                
                if (isMoving && velocity.y === 0) { stepTimer -= delta; if (stepTimer <= 0) { playSound(stepBuffer, 1.0, 0.3, 600); stepTimer = 0.4; } }

                const cPos = controls.getObject().position.clone();
                controls.moveRight(-velocity.x * delta); if (checkCollision(controls.getObject().position)) { controls.getObject().position.x = cPos.x; controls.getObject().position.z = cPos.z; velocity.x = 0; }
                const cPos2 = controls.getObject().position.clone();
                controls.moveForward(-velocity.z * delta); if (checkCollision(controls.getObject().position)) { controls.getObject().position.x = cPos2.x; controls.getObject().position.z = cPos2.z; velocity.z = 0; }
                controls.getObject().position.y += (velocity.y * delta); 
                
                if (controls.getObject().position.y < PLAYER_HEIGHT) { velocity.y = 0; controls.getObject().position.y = PLAYER_HEIGHT; canJump = true; }

                const targetGap = (isMoving ? 10 : 4) + (currentRecoil * 5); 
                dynamicGap += (targetGap - dynamicGap) * 0.2;
                ui.crosshairParts[0].style.bottom = `${dynamicGap}px`; ui.crosshairParts[1].style.top = `${dynamicGap}px`;
                ui.crosshairParts[2].style.right = `${dynamicGap}px`; ui.crosshairParts[3].style.left = `${dynamicGap}px`;

                if (isMoving) { swayTime += delta * 10; swayX += (Math.sin(swayTime) * 0.05 - swayX) * 0.1; swayY += (Math.abs(Math.cos(swayTime)) * 0.05 - swayY) * 0.1; } 
                else { swayX += (0 - swayX) * 0.1; swayY += (0 - swayY) * 0.1; }
                
                let jitterX = 0; let jitterY = 0; if (currentRecoil > 0.1) { jitterX = (Math.random() - 0.5) * currentRecoil * 0.2; jitterY = (Math.random() - 0.5) * currentRecoil * 0.2; }
                const recoilZ = Math.min(currentRecoil, 1);
                weaponGroup.position.x = swayX + jitterX; weaponGroup.position.y = swayY - (isReloading ? 2 : 0) + jitterY;
                const recoilRot = -currentRecoil * 0.4; weaponGroup.rotation.x = isReloading ? -0.5 : recoilRot; weaponGroup.position.z = -recoilZ * 0.5;

                checkLootPickup();
            }

            particles.forEach((p, i) => {
                p.position.add(p.userData.vel.clone().multiplyScalar(delta * 20)); p.material.opacity = p.userData.life; p.scale.setScalar(p.scale.x * 0.95);
                p.userData.life -= p.userData.decay; if(p.userData.life <= 0) { scene.remove(p); particles.splice(i, 1); }
            });

            lootDrops.forEach(box => { box.rotation.y += delta; box.position.y = 2.5 + Math.sin(time * 0.003) * 0.5; });
            shells.forEach((s, i) => { s.position.add(s.userData.vel); s.userData.vel.y -= 0.05; s.rotation.x += 0.1; s.rotation.z += 0.1; if (s.position.y < 0) { s.position.y = 0; s.userData.vel.set(0,0,0); } s.userData.life--; if(s.userData.life < 0) { scene.remove(s); shells.splice(i, 1); } });

            if (!isDead) {
                const pPos = controls.getObject().position;
                enemies.forEach(group => {
                    if (!group.userData.alive) return;
                    group.position.y = 0; group.rotation.x = 0; group.rotation.z = 0;
                    const dx = pPos.x - group.position.x; const dz = pPos.z - group.position.z; const angle = Math.atan2(dx, dz); group.rotation.y = angle;
                    const dist = group.position.distanceTo(pPos); group.userData.walkTime = (group.userData.walkTime || 0);
                    const dir = new THREE.Vector3().subVectors(pPos, group.position).normalize();
                    const ray = new THREE.Raycaster(group.position, dir); const others = mapObjects.filter(o => o !== group && !group.children.includes(o)); const hits = ray.intersectObjects(others);
                    let canSee = true; if (hits.length > 0 && hits[0].distance < dist - 5) canSee = false;

                    if (canSee) {
                         if (dist > 40) { group.position.add(dir.multiplyScalar((group.userData.isBoss ? 20 : 30) * delta)); group.userData.walkTime += delta * 10; group.rotation.z = Math.sin(group.userData.walkTime) * 0.05; }
                         if (dist < 600 && time - group.userData.lastShot > (1200 + Math.random() * 2000)) {
                            group.userData.lastShot = time; playSound(shootBufferPistol, 0.8, 1.0, 1200); 
                            const flash = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshBasicMaterial({color: 0xffff00})); flash.position.set(4, 11, 4); group.add(flash); setTimeout(() => group.remove(flash), 80);
                            if (Math.random() > 0.3) takeDamage(Math.floor(Math.random() * 10) + 5);
                        }
                    }
                    if (group.userData.hpBar) {
                        const pct = Math.max(0, group.userData.hp / group.userData.maxHp);
                        group.userData.hpBar.scale.x = pct;
                        if (pct > 0.5) group.userData.hpBar.material.color.setHex(0x00ff00);
                        else if (pct > 0.25) group.userData.hpBar.material.color.setHex(0xffff00);
                        else group.userData.hpBar.material.color.setHex(0xff0000);
                        group.userData.hpBar.lookAt(camera.position); 
                    }
                });
            }
            renderer.clear(); 
            if (!isScoped) { renderer.render(scene, camera); renderer.clearDepth(); renderer.render(sceneWeapon, cameraWeapon); } else { renderer.render(scene, camera); }
        }
    </script>
</body>
</html>
